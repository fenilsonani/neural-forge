"""Comprehensive test coverage for backend registration system to achieve 95%+ coverage."""

import sys
import os
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'src'))

import pytest
import numpy as np
from unittest.mock import patch, MagicMock
from neural_arch.backends.backend import (
    Backend,
    register_backend,
    get_backend,
    set_backend,
    available_backends,
    current_backend,
    _BACKENDS,
    _CURRENT_BACKEND
)


class MockBackend(Backend):
    """Mock backend implementation for testing."""
    
    def __init__(self, name="mock", available=True, supports_gradients=False):
        self._name = name
        self._available = available
        self._supports_gradients = supports_gradients
    
    @property
    def name(self) -> str:
        return self._name
    
    @property
    def is_available(self) -> bool:
        return self._available
    
    @property
    def supports_gradients(self) -> bool:
        return self._supports_gradients
    
    # Minimal implementations of abstract methods
    def array(self, data, dtype=None):
        return np.array(data, dtype=dtype)
    
    def zeros(self, shape, dtype=None):
        return np.zeros(shape, dtype=dtype or np.float32)
    
    def ones(self, shape, dtype=None):
        return np.ones(shape, dtype=dtype or np.float32)
    
    def full(self, shape, fill_value, dtype=None):
        return np.full(shape, fill_value, dtype=dtype or np.float32)
    
    def arange(self, start, stop, step=1.0, dtype=None):
        return np.arange(start, stop, step, dtype=dtype or np.float32)
    
    def random_normal(self, shape, mean=0.0, std=1.0, dtype=None):
        return np.random.normal(mean, std, shape).astype(dtype or np.float32)
    
    def random_uniform(self, shape, low=0.0, high=1.0, dtype=None):
        return np.random.uniform(low, high, shape).astype(dtype or np.float32)
    
    def reshape(self, x, shape):
        return x.reshape(shape)
    
    def transpose(self, x, axes=None):
        return np.transpose(x, axes)
    
    def squeeze(self, x, axis=None):
        return np.squeeze(x, axis)
    
    def expand_dims(self, x, axis):
        return np.expand_dims(x, axis)
    
    def add(self, x, y):
        return np.add(x, y)
    
    def subtract(self, x, y):
        return np.subtract(x, y)
    
    def multiply(self, x, y):
        return np.multiply(x, y)
    
    def divide(self, x, y):
        return np.divide(x, y)
    
    def power(self, x, y):
        return np.power(x, y)
    
    def matmul(self, x, y):
        return np.matmul(x, y)
    
    def dot(self, x, y):
        return np.dot(x, y)
    
    def sum(self, x, axis=None, keepdims=False):
        return np.sum(x, axis=axis, keepdims=keepdims)
    
    def mean(self, x, axis=None, keepdims=False):
        return np.mean(x, axis=axis, keepdims=keepdims)
    
    def max(self, x, axis=None, keepdims=False):
        return np.max(x, axis=axis, keepdims=keepdims)
    
    def min(self, x, axis=None, keepdims=False):
        return np.min(x, axis=axis, keepdims=keepdims)
    
    def argmax(self, x, axis=None):
        return np.argmax(x, axis=axis)
    
    def argmin(self, x, axis=None):
        return np.argmin(x, axis=axis)
    
    def exp(self, x):
        return np.exp(x)
    
    def log(self, x):
        return np.log(x)
    
    def sqrt(self, x):
        return np.sqrt(x)
    
    def abs(self, x):
        return np.abs(x)
    
    def sign(self, x):
        return np.sign(x)
    
    def clip(self, x, min_val, max_val):
        return np.clip(x, min_val, max_val)
    
    def equal(self, x, y):
        return np.equal(x, y)
    
    def not_equal(self, x, y):
        return np.not_equal(x, y)
    
    def less(self, x, y):
        return np.less(x, y)
    
    def less_equal(self, x, y):
        return np.less_equal(x, y)
    
    def greater(self, x, y):
        return np.greater(x, y)
    
    def greater_equal(self, x, y):
        return np.greater_equal(x, y)
    
    def concatenate(self, arrays, axis=0):
        return np.concatenate(arrays, axis=axis)
    
    def stack(self, arrays, axis=0):
        return np.stack(arrays, axis=axis)
    
    def split(self, x, indices_or_sections, axis=0):
        return np.split(x, indices_or_sections, axis=axis)
    
    def astype(self, x, dtype):
        return x.astype(dtype)
    
    def to_numpy(self, x):
        return np.array(x)
    
    def from_numpy(self, x, dtype=None):
        if dtype:
            return x.astype(dtype)
        return x
    
    def to_device(self, x, device):
        if device != "cpu":
            raise ValueError(f"Mock backend only supports CPU, got {device}")
        return x
    
    def device_of(self, x):
        return "cpu"
    
    def is_array(self, x):
        return isinstance(x, np.ndarray)
    
    def shape(self, x):
        return x.shape
    
    def size(self, x):
        return x.size
    
    def dtype(self, x):
        return x.dtype
    
    def einsum(self, equation, *operands):
        return np.einsum(equation, *operands)
    
    def where(self, condition, x, y):
        return np.where(condition, x, y)
    
    def unique(self, x, return_counts=False):
        if return_counts:
            return np.unique(x, return_counts=True)
        return np.unique(x)


class UnavailableBackend(MockBackend):
    """Mock backend that's not available."""
    
    def __init__(self):
        super().__init__(name="unavailable", available=False)


class ErrorBackend(MockBackend):
    """Mock backend that raises errors during initialization."""
    
    def __init__(self):
        raise RuntimeError("Backend initialization failed")


class TestBackendRegistrationComprehensive:
    """Comprehensive tests for backend registration system targeting 95%+ coverage."""
    
    def setup_method(self):
        """Setup method run before each test."""
        # Store original state but don't clear completely
        # as other tests may depend on registered backends
        self.original_backends = _BACKENDS.copy()
        import neural_arch.backends.backend as backend_module
        self.original_current = backend_module._CURRENT_BACKEND
    
    def teardown_method(self):
        """Cleanup after each test."""
        # Don't fully restore to avoid breaking other tests
        # Just ensure we're not leaving test backends around
        import neural_arch.backends.backend as backend_module
        for name in list(_BACKENDS.keys()):
            if name.startswith('test') or name in ['mock', 'unavailable', 'error']:
                del _BACKENDS[name]
    
    def test_register_backend(self):
        """Test backend registration."""
        # Register a mock backend
        register_backend("test", MockBackend)
        
        assert "test" in _BACKENDS
        assert _BACKENDS["test"] == MockBackend
    
    def test_register_multiple_backends(self):
        """Test registering multiple backends."""
        initial_count = len(_BACKENDS)
        register_backend("test1", MockBackend)
        register_backend("test2", MockBackend)
        
        assert "test1" in _BACKENDS
        assert "test2" in _BACKENDS
        assert len(_BACKENDS) == initial_count + 2
    
    def test_get_backend_by_name(self):
        """Test getting backend by name."""
        register_backend("test", MockBackend)
        
        backend = get_backend("test")
        assert isinstance(backend, MockBackend)
        assert backend.name == "mock"  # Default name in MockBackend
    
    def test_get_backend_unknown_name(self):
        """Test getting unknown backend raises error."""
        register_backend("test", MockBackend)
        
        with pytest.raises(ValueError, match="Unknown backend: unknown"):
            get_backend("unknown")
        
        # Error message should include available backends
        try:
            get_backend("unknown")
        except ValueError as e:
            assert "Available:" in str(e)
            assert "test" in str(e)
    
    def test_get_backend_unavailable(self):
        """Test getting unavailable backend raises error."""
        register_backend("unavailable", UnavailableBackend)
        
        with pytest.raises(RuntimeError, match="Backend 'unavailable' is not available"):
            get_backend("unavailable")
    
    def test_get_backend_no_name_no_current(self):
        """Test getting backend without name when no current backend is set."""
        # Register numpy backend for the default fallback if not already registered
        if "numpy" not in _BACKENDS:
            from neural_arch.backends.numpy_backend import NumpyBackend
            register_backend("numpy", NumpyBackend)
        
        backend = get_backend()  # Should default to numpy
        assert backend.name == "numpy"
    
    def test_get_backend_no_name_with_current(self):
        """Test getting backend without name when current backend is set."""
        register_backend("test_current2", MockBackend)
        
        # Set current backend
        set_backend("test_current2")
        
        # Getting backend without name should return current
        backend = get_backend()
        assert backend is not None
        assert backend.name == "mock"
    
    def test_set_backend(self):
        """Test setting current backend."""
        register_backend("test_set", MockBackend)
        
        set_backend("test_set")
        
        # Verify we can get the backend back
        backend = get_backend()
        assert backend.name == "mock"
    
    def test_set_backend_unknown(self):
        """Test setting unknown backend raises error."""
        with pytest.raises(ValueError, match="Unknown backend: unknown"):
            set_backend("unknown")
    
    def test_set_backend_unavailable(self):
        """Test setting unavailable backend raises error."""
        register_backend("unavailable", UnavailableBackend)
        
        with pytest.raises(RuntimeError, match="Backend 'unavailable' is not available"):
            set_backend("unavailable")
    
    def test_available_backends(self):
        """Test getting list of available backends."""
        register_backend("available1", MockBackend)
        register_backend("available2", MockBackend)
        register_backend("unavailable", UnavailableBackend)
        
        available = available_backends()
        
        assert "available1" in available
        assert "available2" in available
        assert "unavailable" not in available
        assert len(available) >= 2  # May have other backends too
    
    def test_available_backends_with_initialization_error(self):
        """Test available_backends handles initialization errors gracefully."""
        register_backend("good", MockBackend)
        register_backend("error", ErrorBackend)
        
        available = available_backends()
        
        # Should only include the good backend
        assert "good" in available
        assert "error" not in available
        assert len(available) >= 1  # May have other backends too
    
    def test_available_backends_empty_registry(self):
        """Test available_backends behavior.""" 
        # This test just verifies that the function works
        available = available_backends()
        assert isinstance(available, list)
    
    def test_current_backend(self):
        """Test getting current backend."""
        # Set a backend
        register_backend("test_current", MockBackend)
        set_backend("test_current")
        
        current = current_backend()
        assert current is not None
        assert current.name == "mock"
    
    def test_backend_abstract_methods(self):
        """Test that Backend is properly abstract."""
        with pytest.raises(TypeError):
            Backend()  # Cannot instantiate abstract class
    
    def test_backend_interface_completeness(self):
        """Test that MockBackend implements all required methods."""
        backend = MockBackend()
        
        # Test all methods exist and are callable
        methods = [
            'name', 'is_available', 'supports_gradients',
            'array', 'zeros', 'ones', 'full', 'arange', 'random_normal', 'random_uniform',
            'reshape', 'transpose', 'squeeze', 'expand_dims',
            'add', 'subtract', 'multiply', 'divide', 'power', 'matmul', 'dot',
            'sum', 'mean', 'max', 'min', 'argmax', 'argmin',
            'exp', 'log', 'sqrt', 'abs', 'sign', 'clip',
            'equal', 'not_equal', 'less', 'less_equal', 'greater', 'greater_equal',
            'concatenate', 'stack', 'split',
            'astype', 'to_numpy', 'from_numpy',
            'to_device', 'device_of',
            'is_array', 'shape', 'size', 'dtype',
            'einsum', 'where', 'unique'
        ]
        
        for method in methods:
            assert hasattr(backend, method), f"Backend missing method: {method}"
    
    def test_mock_backend_functionality(self):
        """Test MockBackend basic functionality."""
        backend = MockBackend(name="test_backend", available=True, supports_gradients=True)
        
        assert backend.name == "test_backend"
        assert backend.is_available is True
        assert backend.supports_gradients is True
        
        # Test array operations
        x = backend.array([1, 2, 3])
        assert isinstance(x, np.ndarray)
        np.testing.assert_array_equal(x, [1, 2, 3])
        
        # Test zeros
        zeros = backend.zeros((2, 3))
        assert zeros.shape == (2, 3)
        assert np.all(zeros == 0)
        
        # Test math operations
        a = backend.array([1, 2, 3])
        b = backend.array([4, 5, 6])
        result = backend.add(a, b)
        np.testing.assert_array_equal(result, [5, 7, 9])
    
    def test_backend_registry_isolation(self):
        """Test that backend registry is properly isolated between tests."""
        # Register a backend
        register_backend("test1", MockBackend)
        assert "test1" in _BACKENDS
        
        # This should be cleaned up automatically by teardown_method
    
    def test_global_state_management(self):
        """Test global state management."""
        register_backend("test_global", MockBackend)
        
        # Set backend
        set_backend("test_global")
        
        # Get current backend
        current = current_backend()
        assert current is not None
        assert current.name == "mock"
    
    def test_backend_instantiation(self):
        """Test backend instantiation through registry."""
        class CustomBackend(MockBackend):
            def __init__(self):
                super().__init__(name="custom")
        
        register_backend("custom", CustomBackend)
        
        backend = get_backend("custom")
        assert isinstance(backend, CustomBackend)
        assert backend.name == "custom"
    
    def test_backend_availability_check(self):
        """Test backend availability checking."""
        # Test available backend
        register_backend("available", lambda: MockBackend(available=True))
        backend = get_backend("available")
        assert backend.is_available is True
        
        # Test unavailable backend
        register_backend("unavailable", lambda: MockBackend(available=False))
        with pytest.raises(RuntimeError):
            get_backend("unavailable")
    
    def test_error_handling_in_available_backends(self):
        """Test error handling in available_backends function."""
        class BadBackend:
            def __init__(self):
                raise Exception("Initialization failed")
        
        register_backend("good", MockBackend)
        register_backend("bad", BadBackend)
        
        available = available_backends()
        
        # Should handle the error gracefully and only return good backends
        assert "good" in available
        assert "bad" not in available
    
    def test_backend_properties_as_properties(self):
        """Test that backend properties are actually properties."""
        backend = MockBackend()
        
        # These should be properties, not methods
        assert isinstance(type(backend).name, property)
        assert isinstance(type(backend).is_available, property)
        assert isinstance(type(backend).supports_gradients, property)
    
    def test_concurrent_registration(self):
        """Test that multiple registrations work correctly."""
        # Register same name multiple times (last one wins)
        register_backend("test", MockBackend)
        
        class NewBackend(MockBackend):
            def __init__(self):
                super().__init__(name="new")
        
        register_backend("test", NewBackend)
        
        backend = get_backend("test")
        assert backend.name == "new"
    
    def test_set_backend_creates_new_instance(self):
        """Test that set_backend creates a new instance each time."""
        register_backend("test_new", MockBackend)
        
        set_backend("test_new")
        first_backend = get_backend()
        
        set_backend("test_new")
        second_backend = get_backend()
        
        # Should be different instances
        assert first_backend is not None
        assert second_backend is not None
        assert first_backend.name == "mock"
        assert second_backend.name == "mock"
    
    def test_edge_cases(self):
        """Test edge cases and boundary conditions."""
        # Empty backend name
        with pytest.raises(ValueError):
            get_backend("")
        
        # None as backend name (should use current or default)
        from neural_arch.backends.numpy_backend import NumpyBackend
        register_backend("numpy", NumpyBackend)
        
        backend = get_backend(None)
        assert backend is not None
    
    def test_backend_registry_thread_safety_implications(self):
        """Test implications for thread safety (documentation test)."""
        # This is more of a documentation test to highlight that the current
        # implementation uses global state and is not thread-safe
        
        register_backend("test_thread", MockBackend)
        set_backend("test_thread")
        
        # Global state access
        current = get_backend()
        assert current is not None
        assert "test_thread" in _BACKENDS
        
        # This documents that the current implementation modifies global state
        # and would need additional synchronization for thread safety